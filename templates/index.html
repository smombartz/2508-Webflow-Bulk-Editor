<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webflow CMS Bulk Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8fafc;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #1e293b;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .header p {
            color: #64748b;
            font-size: 1.1rem;
        }
        
        .controls {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        
        .control-group {
            display: flex;
            gap: 20px;
            align-items: end;
            flex-wrap: wrap;
        }
        
        .form-group {
            flex: 1;
            min-width: 200px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #374151;
        }
        
        select, button {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.2s;
        }
        
        select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        select:disabled {
            background: #f3f4f6;
            color: #9ca3af;
        }
        
        .select-with-refresh {
            display: flex;
            gap: 8px;
            align-items: stretch;
        }
        
        .select-with-refresh select {
            flex: 1;
        }
        
        .btn-refresh {
            background: #6b7280;
            color: white;
            border: none;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: auto;
            width: 36px;
            height: 36px;
            transition: all 0.2s ease;
        }
        
        .btn-refresh:hover:not(:disabled) {
            background: #4b5563;
            transform: rotate(90deg);
        }
        
        .btn-refresh:disabled {
            background: #d1d5db;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-refresh svg {
            transition: transform 0.2s ease;
        }
        
        .spinning {
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        button {
            background: #3b82f6;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            min-width: 150px;
        }
        
        button:hover:not(:disabled) {
            background: #2563eb;
            transform: translateY(-1px);
        }
        
        button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 40px;
            color: #6b7280;
        }
        
        .spinner {
            display: inline-block;
            width: 24px;
            height: 24px;
            border: 3px solid #e5e7eb;
            border-radius: 50%;
            border-top-color: #3b82f6;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .error {
            background: #fef2f2;
            color: #dc2626;
            padding: 16px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #fecaca;
        }
        
        .success {
            background: #f0fdf4;
            color: #16a34a;
            padding: 16px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #bbf7d0;
        }
        
        .editor-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
            display: none;
        }
        
        .editor-header {
            background: #f8fafc;
            padding: 20px 25px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .collection-info h3 {
            color: #1e293b;
            margin-bottom: 5px;
        }
        
        .collection-info p {
            color: #64748b;
            font-size: 0.9rem;
        }
        
        .editor-actions {
            display: flex;
            gap: 10px;
        }
        
        .btn-publish {
            background: #059669;
            padding: 10px 20px;
            border-radius: 6px;
            color: white;
            border: none;
            font-weight: 600;
            cursor: pointer;
        }
        
        .btn-publish:hover:not(:disabled) {
            background: #047857;
        }
        
        .btn-add-item {
            background: #3b82f6;
            padding: 10px 20px;
            border-radius: 6px;
            color: white;
            border: none;
            font-weight: 600;
            cursor: pointer;
        }
        
        .btn-add-item:hover:not(:disabled) {
            background: #2563eb;
        }
        
        .new-item-row {
            background-color: #f0f9ff;
            border-left: 4px solid #3b82f6;
        }
        
        .new-item-row .editor-table input,
        .new-item-row .editor-table textarea,
        .new-item-row .editor-table select {
            border-color: #3b82f6;
        }
        
        .pending-upload {
            border-left: 4px solid #8b5cf6;
        }
        
        .pending-upload .editor-table input,
        .pending-upload .editor-table textarea,
        .pending-upload .editor-table select {
            border-color: #8b5cf6;
        }
        
        .file-uploaded {
            background-color: #f0fdf4;
            border-left: 4px solid #10b981;
        }
        
        .file-uploaded .editor-table input,
        .file-uploaded .editor-table textarea,
        .file-uploaded .editor-table select {
            border-color: #10b981;
        }
        
        .btn-delete {
            background: #ef4444;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
        }
        
        .btn-delete:hover {
            background: #dc2626;
        }
        
        .delete-column {
            width: 80px;
            text-align: center;
        }
        
        .deleting {
            opacity: 0.5;
            pointer-events: none;
        }
        
        .bulk-upload-section {
            background: #f8fafc;
            padding: 20px 25px;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .bulk-upload-controls {
            display: flex;
            gap: 15px;
            align-items: end;
            flex-wrap: wrap;
        }
        
        .bulk-upload-group {
            display: flex;
            gap: 10px;
            align-items: end;
        }
        
        .btn-bulk-upload {
            background: #8b5cf6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
        }
        
        .btn-bulk-upload:hover:not(:disabled) {
            background: #7c3aed;
        }
        
        .btn-bulk-upload:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }
        
        .file-input-hidden {
            display: none;
        }
        
        .upload-progress {
            margin-top: 10px;
            padding: 10px;
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 6px;
            display: none;
        }
        
        .upload-progress-bar {
            width: 100%;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        .upload-progress-fill {
            height: 100%;
            background: #f59e0b;
            transition: width 0.3s ease;
        }
        
        .table-container {
            overflow-x: auto;
            max-height: 70vh;
        }
        
        .editor-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .editor-table th {
            background: #f8fafc;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #374151;
            border-bottom: 2px solid #e5e7eb;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .editor-table td {
            padding: 12px;
            border-bottom: 1px solid #f1f5f9;
            vertical-align: top;
        }
        
        .editor-table tr:hover {
            background: #fafbfc;
        }
        
        .editor-table input,
        .editor-table textarea,
        .editor-table select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 14px;
            min-width: 150px;
        }
        
        .editor-table input:focus,
        .editor-table textarea:focus,
        .editor-table select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }
        
        .editor-table textarea {
            min-height: 60px;
            resize: vertical;
        }
        
        .editor-table .modified {
            background-color: #fef3c7;
            border-color: #f59e0b;
        }
        
        .pagination {
            padding: 20px 25px;
            display: flex;
            justify-content: between;
            align-items: center;
            background: #f8fafc;
            border-top: 1px solid #e5e7eb;
        }
        
        .pagination-info {
            color: #64748b;
            font-size: 0.9rem;
        }
        
        .pagination-controls {
            display: flex;
            gap: 10px;
        }
        
        .pagination-controls button {
            width: auto;
            padding: 8px 16px;
            font-size: 14px;
            min-width: auto;
        }
        
        .image-preview {
            max-width: 60px;
            max-height: 60px;
            object-fit: cover;
            border-radius: 4px;
            margin-top: 5px;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .status-connected { background: #10b981; }
        .status-error { background: #ef4444; }
        .status-loading { background: #f59e0b; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Webflow CMS Bulk Editor</h1>
            <p>Transform your Webflow CMS management with seamless bulk editing capabilities</p>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <div class="form-group">
                    <label for="site-select">
                        <span id="connection-status" class="status-indicator status-loading"></span>
                        Select Webflow Site
                    </label>
                    <select id="site-select" disabled>
                        <option value="">Loading sites...</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="collection-select">Select Collection</label>
                    <div class="select-with-refresh">
                        <select id="collection-select" disabled>
                            <option value="">Select a site first</option>
                        </select>
                        <button id="refresh-collection" class="btn-refresh" disabled title="Refresh collection data">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M21 12C21 16.97 16.97 21 12 21C7.03 21 3 16.97 3 12C3 7.03 7.03 3 12 3C13.83 3 15.5 3.58 16.85 4.58L15.85 5.58C14.77 4.88 13.45 4.5 12 4.5C7.86 4.5 4.5 7.86 4.5 12C4.5 16.14 7.86 19.5 12 19.5C16.14 19.5 19.5 16.14 19.5 12H18L21 9L24 12H21Z" fill="currentColor"/>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="messages"></div>
        
        <div class="loading" id="loading">
            <div class="spinner"></div>
            Loading collection data...
        </div>
        
        <div class="editor-container" id="editor">
            <div class="editor-header">
                <div class="collection-info">
                    <h3 id="collection-name">Collection Name</h3>
                    <p id="collection-stats">0 items loaded</p>
                </div>
                <div class="editor-actions">
                    <button class="btn-add-item" id="add-item" disabled>
                        Add Item
                    </button>
                    <button class="btn-publish" id="update-publish" disabled>
                        Update & Publish
                    </button>
                </div>
            </div>
            
            <div class="bulk-upload-section" id="bulk-upload-section">
                <div class="bulk-upload-controls">
                    <div class="form-group">
                        <label for="field-select">Upload to Field:</label>
                        <select id="field-select" disabled>
                            <option value="">Select a field...</option>
                        </select>
                    </div>
                    <div class="bulk-upload-group">
                        <button class="btn-bulk-upload" id="bulk-upload-btn" disabled>
                            Bulk Upload
                        </button>
                        <input type="file" id="file-input" class="file-input-hidden" multiple accept="image/*,video/*,.pdf,.doc,.docx,.txt">
                    </div>
                </div>
                <div class="upload-progress" id="upload-progress">
                    <div id="upload-status">Uploading files...</div>
                    <div class="upload-progress-bar">
                        <div class="upload-progress-fill" id="upload-progress-fill" style="width: 0%"></div>
                    </div>
                </div>
            </div>
            
            <div class="table-container">
                <table class="editor-table" id="items-table">
                    <thead id="table-head">
                        <!-- Dynamic headers will be inserted here -->
                    </thead>
                    <tbody id="table-body">
                        <!-- Dynamic content will be inserted here -->
                    </tbody>
                </table>
            </div>
            
            <div class="pagination" id="pagination" style="display: none;">
                <div class="pagination-info">
                    <span id="pagination-info">Showing 0-0 of 0 items</span>
                </div>
                <div class="pagination-controls">
                    <button id="prev-page" disabled>Previous</button>
                    <button id="next-page" disabled>Next</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        class WebflowBulkEditor {
            constructor() {
                this.currentSiteId = null;
                this.currentCollectionId = null;
                this.collectionSchema = null;
                this.collectionItems = [];
                this.currentPage = 0;
                this.itemsPerPage = 100;
                this.totalItems = 0;
                this.modifiedItems = new Set();
                this.newItemCounter = 0;
                this.pendingFiles = new Map(); // Store files for later upload
                
                this.initializeElements();
                this.bindEvents();
                this.checkAPIConnection();
            }
            
            initializeElements() {
                this.elements = {
                    siteSelect: document.getElementById('site-select'),
                    collectionSelect: document.getElementById('collection-select'),
                    refreshCollectionButton: document.getElementById('refresh-collection'),
                    editor: document.getElementById('editor'),
                    loading: document.getElementById('loading'),
                    messages: document.getElementById('messages'),
                    tableHead: document.getElementById('table-head'),
                    tableBody: document.getElementById('table-body'),
                    collectionName: document.getElementById('collection-name'),
                    collectionStats: document.getElementById('collection-stats'),
                    addItemButton: document.getElementById('add-item'),
                    updatePublishButton: document.getElementById('update-publish'),
                    pagination: document.getElementById('pagination'),
                    paginationInfo: document.getElementById('pagination-info'),
                    prevPageButton: document.getElementById('prev-page'),
                    nextPageButton: document.getElementById('next-page'),
                    connectionStatus: document.getElementById('connection-status'),
                    fieldSelect: document.getElementById('field-select'),
                    bulkUploadButton: document.getElementById('bulk-upload-btn'),
                    fileInput: document.getElementById('file-input'),
                    uploadProgress: document.getElementById('upload-progress'),
                    uploadStatus: document.getElementById('upload-status'),
                    uploadProgressFill: document.getElementById('upload-progress-fill')
                };
            }
            
            bindEvents() {
                this.elements.siteSelect.addEventListener('change', () => this.onSiteChange());
                this.elements.collectionSelect.addEventListener('change', () => this.onCollectionChange());
                this.elements.refreshCollectionButton.addEventListener('click', () => this.refreshCollection());
                this.elements.addItemButton.addEventListener('click', () => this.addNewItem());
                this.elements.updatePublishButton.addEventListener('click', () => this.updateAndPublish());
                this.elements.prevPageButton.addEventListener('click', () => this.loadPreviousPage());
                this.elements.nextPageButton.addEventListener('click', () => this.loadNextPage());
                this.elements.bulkUploadButton.addEventListener('click', () => this.triggerBulkUpload());
                this.elements.fileInput.addEventListener('change', (e) => this.handleFileSelection(e));
            }
            
            async checkAPIConnection() {
                try {
                    const response = await fetch('/api/health');
                    const result = await response.json();
                    
                    if (result.success) {
                        this.elements.connectionStatus.className = 'status-indicator status-connected';
                        await this.loadSites();
                        
                        // After loading sites, restore previous selections
                        await this.restorePreviousSelections();
                    } else {
                        this.showError(result.error);
                        this.elements.connectionStatus.className = 'status-indicator status-error';
                        this.elements.siteSelect.innerHTML = '<option value="">API connection failed</option>';
                    }
                } catch (error) {
                    this.showError('Failed to connect to API');
                    this.elements.connectionStatus.className = 'status-indicator status-error';
                }
            }
            
            async loadSites() {
                try {
                    const response = await fetch('/api/sites');
                    const result = await response.json();
                    
                    if (result.success) {
                        this.populateSiteSelect(result.sites);
                    } else {
                        this.showError(result.error);
                    }
                } catch (error) {
                    this.showError('Failed to load sites');
                }
            }
            
            populateSiteSelect(sites) {
                this.elements.siteSelect.innerHTML = '<option value="">Select a site...</option>';
                
                sites.forEach(site => {
                    const option = document.createElement('option');
                    option.value = site.id;
                    option.textContent = site.displayName;
                    this.elements.siteSelect.appendChild(option);
                });
                
                this.elements.siteSelect.disabled = false;
            }
            
            async onSiteChange() {
                const siteId = this.elements.siteSelect.value;
                
                if (!siteId) {
                    this.resetCollectionSelect();
                    return;
                }
                
                this.currentSiteId = siteId;
                await this.loadCollections(siteId);
            }
            
            async loadCollections(siteId) {
                this.elements.collectionSelect.disabled = true;
                this.elements.collectionSelect.innerHTML = '<option value="">Loading collections...</option>';
                
                try {
                    const response = await fetch(`/api/sites/${siteId}/collections`);
                    const result = await response.json();
                    
                    if (result.success) {
                        this.populateCollectionSelect(result.collections);
                    } else {
                        this.showError(result.error);
                        this.resetCollectionSelect();
                    }
                } catch (error) {
                    this.showError('Failed to load collections');
                    this.resetCollectionSelect();
                }
            }
            
            populateCollectionSelect(collections) {
                this.elements.collectionSelect.innerHTML = '<option value="">Select a collection...</option>';
                
                collections.forEach(collection => {
                    const option = document.createElement('option');
                    option.value = collection.id;
                    option.textContent = collection.displayName;
                    this.elements.collectionSelect.appendChild(option);
                });
                
                this.elements.collectionSelect.disabled = false;
            }
            
            resetCollectionSelect() {
                this.elements.collectionSelect.innerHTML = '<option value="">Select a site first</option>';
                this.elements.collectionSelect.disabled = true;
                this.elements.editor.style.display = 'none';
            }
            
            async onCollectionChange() {
                const collectionId = this.elements.collectionSelect.value;
                this.currentCollectionId = collectionId;
                
                if (collectionId) {
                    // Enable refresh button when a collection is selected
                    this.elements.refreshCollectionButton.disabled = false;
                    
                    // Auto-load the collection when selected
                    await this.loadCollection();
                } else {
                    // Hide editor and disable refresh button if no collection selected
                    this.elements.editor.style.display = 'none';
                    this.elements.refreshCollectionButton.disabled = true;
                }
            }
            
            async refreshCollection() {
                if (!this.currentCollectionId) {
                    this.showError('No collection selected');
                    return;
                }
                
                // Add visual feedback
                const originalText = this.elements.refreshCollectionButton.innerHTML;
                this.elements.refreshCollectionButton.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="spinning">
                        <path d="M21 12C21 16.97 16.97 21 12 21C7.03 21 3 16.97 3 12C3 7.03 7.03 3 12 3C13.83 3 15.5 3.58 16.85 4.58L15.85 5.58C14.77 4.88 13.45 4.5 12 4.5C7.86 4.5 4.5 7.86 4.5 12C4.5 16.14 7.86 19.5 12 19.5C16.14 19.5 19.5 16.14 19.5 12H18L21 9L24 12H21Z" fill="currentColor"/>
                    </svg>
                `;
                this.elements.refreshCollectionButton.disabled = true;
                
                try {
                    // Reset to first page and clear modifications
                    this.currentPage = 0;
                    this.modifiedItems.clear();
                    this.pendingFiles.clear();
                    
                    // Reload collection using the existing loadCollection method
                    await this.loadCollection();
                    
                    this.showSuccess('Collection refreshed successfully');
                    
                } catch (error) {
                    console.error('Collection refresh failed:', error);
                    this.showError(`Failed to refresh collection: ${error.message}`);
                } finally {
                    // Restore button
                    this.elements.refreshCollectionButton.innerHTML = originalText;
                    this.elements.refreshCollectionButton.disabled = false;
                }
            }
            
            async loadCollection() {
                if (!this.currentCollectionId) return;
                
                this.showLoading(true);
                this.hideMessages();
                
                try {
                    // Load collection schema and items in parallel
                    const [schemaResponse, itemsResponse] = await Promise.all([
                        fetch(`/api/collections/${this.currentCollectionId}`),
                        fetch(`/api/collections/${this.currentCollectionId}/items?limit=${this.itemsPerPage}&offset=0`)
                    ]);
                    
                    const schemaResult = await schemaResponse.json();
                    const itemsResult = await itemsResponse.json();
                    
                    if (schemaResult.success && itemsResult.success) {
                        this.collectionSchema = schemaResult.collection;
                        this.collectionItems = itemsResult.items;
                        this.totalItems = itemsResult.pagination.total;
                        this.currentPage = 0;
                        
                        this.renderEditor();
                        this.elements.editor.style.display = 'block';
                    } else {
                        this.showError(schemaResult.error || itemsResult.error);
                    }
                } catch (error) {
                    this.showError('Failed to load collection data');
                }
                
                this.showLoading(false);
            }
            
            renderEditor() {
                this.renderTableHeaders();
                this.renderTableBody();
                this.updateCollectionInfo();
                this.updatePagination();
                this.populateFieldSelect();
                this.elements.addItemButton.disabled = false;
                this.elements.updatePublishButton.disabled = false;
            }
            
            renderTableHeaders() {
                const headerRow = document.createElement('tr');
                
                this.collectionSchema.fields.forEach(field => {
                    const th = document.createElement('th');
                    th.textContent = field.displayName;
                    th.setAttribute('data-field-slug', field.slug);
                    th.setAttribute('data-field-type', field.type);
                    headerRow.appendChild(th);
                });
                
                // Add delete column header
                const deleteHeader = document.createElement('th');
                deleteHeader.textContent = 'Actions';
                deleteHeader.className = 'delete-column';
                headerRow.appendChild(deleteHeader);
                
                this.elements.tableHead.innerHTML = '';
                this.elements.tableHead.appendChild(headerRow);
            }
            
            renderTableBody() {
                this.elements.tableBody.innerHTML = '';
                
                this.collectionItems.forEach(item => {
                    const row = this.createItemRow(item);
                    this.elements.tableBody.appendChild(row);
                });
            }
            
            createItemRow(item) {
                const row = document.createElement('tr');
                row.setAttribute('data-item-id', item.id);
                
                this.collectionSchema.fields.forEach(field => {
                    const td = document.createElement('td');
                    const input = this.createFieldInput(field, item.fieldData[field.slug], item.id);
                    td.appendChild(input);
                    row.appendChild(td);
                });
                
                // Add delete button cell
                const deleteCell = document.createElement('td');
                deleteCell.className = 'delete-column';
                
                const deleteButton = document.createElement('button');
                deleteButton.className = 'btn-delete';
                deleteButton.textContent = 'Delete';
                deleteButton.setAttribute('data-item-id', item.id);
                deleteButton.addEventListener('click', () => this.deleteItem(item.id, row));
                
                deleteCell.appendChild(deleteButton);
                row.appendChild(deleteCell);
                
                return row;
            }
            
            createFieldInput(field, value, itemId) {
                const inputId = `${itemId}-${field.slug}`;
                let input;
                
                console.log(`Creating input for field:`, {
                    fieldSlug: field.slug,
                    fieldType: field.type,
                    itemId,
                    value
                });
                
                switch (field.type) {
                    case 'PlainText':
                    case 'Link':
                    case 'Email':
                    case 'Phone':
                        input = document.createElement('input');
                        input.type = this.getInputType(field.type);
                        input.value = value || '';
                        break;
                        
                    case 'Number':
                        input = document.createElement('input');
                        input.type = 'number';
                        input.value = value || '';
                        input.step = 'any';
                        break;
                        
                    case 'RichText':
                        input = document.createElement('textarea');
                        input.value = value || '';
                        break;
                        
                    case 'Switch':
                        input = document.createElement('input');
                        input.type = 'checkbox';
                        input.checked = value === true;
                        break;
                        
                    case 'Option':
                        input = document.createElement('select');
                        const defaultOption = document.createElement('option');
                        defaultOption.value = '';
                        defaultOption.textContent = 'Select option...';
                        input.appendChild(defaultOption);
                        
                        if (field.options) {
                            field.options.forEach(option => {
                                const optionElement = document.createElement('option');
                                optionElement.value = option.name;
                                optionElement.textContent = option.name;
                                optionElement.selected = value === option.name;
                                input.appendChild(optionElement);
                            });
                        }
                        break;
                        
                    case 'DateTime':
                        input = document.createElement('input');
                        input.type = 'datetime-local';
                        if (value) {
                            // Convert ISO string to datetime-local format
                            const date = new Date(value);
                            input.value = date.toISOString().slice(0, 16);
                        }
                        break;
                        
                    case 'ImageRef':
                    case 'FileRef':
                        input = this.createFileInput(field, value, itemId);
                        break;
                        
                    case 'ItemRef':
                        input = document.createElement('input');
                        input.type = 'text';
                        input.placeholder = 'Referenced item ID';
                        input.value = value || '';
                        break;
                        
                    case 'ItemRefSet':
                        input = document.createElement('input');
                        input.type = 'text';
                        input.placeholder = 'Comma-separated item IDs';
                        input.value = Array.isArray(value) ? value.join(', ') : (value || '');
                        break;
                        
                    default:
                        input = document.createElement('input');
                        input.type = 'text';
                        input.value = typeof value === 'object' ? JSON.stringify(value) : (value || '');
                }
                
                // Set attributes for all inputs (file inputs already handle this in createFileInput)
                if (field.type !== 'ImageRef' && field.type !== 'FileRef') {
                    input.id = inputId;
                    input.setAttribute('data-field-slug', field.slug);
                    input.setAttribute('data-field-type', field.type);
                    input.setAttribute('data-item-id', itemId);
                    
                    // Add change event listener to track modifications
                    input.addEventListener('input', () => this.onFieldChange(input));
                    input.addEventListener('change', () => this.onFieldChange(input));
                } else {
                    // For file inputs (containers), add event listeners to the actual input element
                    const actualInput = input.querySelector('input');
                    if (actualInput) {
                        actualInput.addEventListener('input', () => this.onFieldChange(actualInput));
                        actualInput.addEventListener('change', () => this.onFieldChange(actualInput));
                    }
                }
                
                // Validate that attributes were set correctly
                if (!field.slug || !field.type) {
                    console.error('Field missing slug or type:', field);
                }
                
                return input;
            }
            
            createFileInput(field, value, itemId) {
                const container = document.createElement('div');
                
                const input = document.createElement('input');
                input.type = 'text';
                input.placeholder = `${field.type === 'ImageRef' || field.type === 'Image' ? 'Image' : 'File'} URL`;
                input.id = `${itemId}-${field.slug}`;
                input.setAttribute('data-field-slug', field.slug);
                input.setAttribute('data-field-type', field.type);
                input.setAttribute('data-item-id', itemId);
                
                if (value && typeof value === 'object' && value.url) {
                    if (value.isLocal) {
                        // Handle local file preview
                        input.value = value.fileName || 'Local file selected';
                        input.style.backgroundColor = '#f3f4f6';
                        input.readOnly = true;
                        input.title = `Local file: ${value.fileName}. Will be uploaded when you publish.`;
                        
                        if ((field.type === 'ImageRef' || field.type === 'Image') && value.url) {
                            const preview = document.createElement('img');
                            preview.src = value.url;
                            preview.className = 'image-preview';
                            preview.style.border = '2px solid #8b5cf6';
                            preview.title = 'Local file preview - will be uploaded on publish';
                            preview.onerror = () => preview.style.display = 'none';
                            container.appendChild(preview);
                        }
                    } else {
                        // Handle regular URL
                        input.value = value.url;
                        
                        if ((field.type === 'ImageRef' || field.type === 'Image') && value.url) {
                            const preview = document.createElement('img');
                            preview.src = value.url;
                            preview.className = 'image-preview';
                            preview.onerror = () => preview.style.display = 'none';
                            container.appendChild(preview);
                        }
                    }
                } else if (typeof value === 'string') {
                    input.value = value;
                }
                
                container.appendChild(input);
                
                // Set the container to handle the input properly
                container.querySelector = function(selector) {
                    if (selector === 'input') return input;
                    return HTMLElement.prototype.querySelector.call(this, selector);
                };
                
                return container;
            }
            
            getInputType(fieldType) {
                switch (fieldType) {
                    case 'Email': return 'email';
                    case 'Phone': return 'tel';
                    case 'Link': return 'url';
                    default: return 'text';
                }
            }
            
            onFieldChange(input) {
                const itemId = input.getAttribute('data-item-id');
                this.modifiedItems.add(itemId);
                input.classList.add('modified');
                
                // Update collection stats
                this.updateCollectionInfo();
            }
            
            updateCollectionInfo() {
                this.elements.collectionName.textContent = this.collectionSchema.displayName;
                
                const startItem = this.currentPage * this.itemsPerPage + 1;
                const endItem = Math.min((this.currentPage + 1) * this.itemsPerPage, this.totalItems);
                const modifiedCount = this.modifiedItems.size;
                
                this.elements.collectionStats.textContent = 
                    `${startItem}-${endItem} of ${this.totalItems} items` + 
                    (modifiedCount > 0 ? ` • ${modifiedCount} modified` : '');
            }
            
            updatePagination() {
                const hasNextPage = (this.currentPage + 1) * this.itemsPerPage < this.totalItems;
                const hasPrevPage = this.currentPage > 0;
                
                this.elements.prevPageButton.disabled = !hasPrevPage;
                this.elements.nextPageButton.disabled = !hasNextPage;
                
                const startItem = this.currentPage * this.itemsPerPage + 1;
                const endItem = Math.min((this.currentPage + 1) * this.itemsPerPage, this.totalItems);
                
                this.elements.paginationInfo.textContent = `Showing ${startItem}-${endItem} of ${this.totalItems} items`;
                
                this.elements.pagination.style.display = this.totalItems > this.itemsPerPage ? 'flex' : 'none';
            }
            
            async loadNextPage() {
                if ((this.currentPage + 1) * this.itemsPerPage >= this.totalItems) return;
                
                this.currentPage++;
                await this.loadPageItems();
            }
            
            async loadPreviousPage() {
                if (this.currentPage <= 0) return;
                
                this.currentPage--;
                await this.loadPageItems();
            }
            
            async loadPageItems() {
                this.showLoading(true);
                
                try {
                    const offset = this.currentPage * this.itemsPerPage;
                    const response = await fetch(
                        `/api/collections/${this.currentCollectionId}/items?limit=${this.itemsPerPage}&offset=${offset}`
                    );
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.collectionItems = result.items;
                        this.renderTableBody();
                        this.updateCollectionInfo();
                        this.updatePagination();
                    } else {
                        this.showError(result.error);
                    }
                } catch (error) {
                    this.showError('Failed to load page items');
                }
                
                this.showLoading(false);
            }
            
            addNewItem() {
                if (!this.collectionSchema || !this.collectionSchema.fields) {
                    this.showError('No collection schema available');
                    return;
                }
                
                // Generate a temporary ID for the new item
                this.newItemCounter++;
                const tempId = `new-item-${Date.now()}-${this.newItemCounter}`;
                
                console.log('Adding new item with ID:', tempId);
                
                // Create new item object with empty field data
                const newItem = {
                    id: tempId,
                    fieldData: {},
                    isNew: true
                };
                
                // Initialize empty values for all fields
                this.collectionSchema.fields.forEach(field => {
                    newItem.fieldData[field.slug] = this.getDefaultValueForField(field);
                });
                
                // Create the table row for the new item
                const newRow = this.createItemRow(newItem);
                newRow.classList.add('new-item-row');
                
                // Insert at the top of the table
                if (this.elements.tableBody.firstChild) {
                    this.elements.tableBody.insertBefore(newRow, this.elements.tableBody.firstChild);
                } else {
                    this.elements.tableBody.appendChild(newRow);
                }
                
                // Mark the new item as modified so it gets included in updates
                this.modifiedItems.add(tempId);
                
                // Update the collection info
                this.updateCollectionInfo();
                
                // Show success message
                this.showSuccess('New item added. Fill in the fields and click "Update & Publish" to save.');
                
                // Scroll the new row into view
                newRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
            
            getDefaultValueForField(field) {
                switch (field.type) {
                    case 'Switch':
                        return false;
                    case 'Number':
                        return null;
                    case 'DateTime':
                        return null;
                    case 'ImageRef':
                    case 'FileRef':
                        return null;
                    case 'ItemRefSet':
                        return [];
                    default:
                        return '';
                }
            }
            
            async updateAndPublish() {
                if (this.modifiedItems.size === 0) {
                    this.showError('No changes to save');
                    return;
                }
                
                // Show confirmation message instead of popup
                const pendingFilesCount = this.pendingFiles.size;
                const statusMessage = pendingFilesCount > 0 
                    ? `Starting update for ${this.modifiedItems.size} modified items (including ${pendingFilesCount} file uploads). This will make your changes live on the website.`
                    : `Starting update for ${this.modifiedItems.size} modified items. This will make your changes live on the website.`;
                    
                this.showSuccess(statusMessage);
                
                this.elements.updatePublishButton.disabled = true;
                
                try {
                    let totalOperations = 0;
                    let completedOperations = 0;
                    
                    // Count total operations
                    if (pendingFilesCount > 0) totalOperations++; // File upload step
                    
                    // Step 1: Upload pending files first
                    if (pendingFilesCount > 0) {
                        this.elements.updatePublishButton.textContent = `Step ${completedOperations + 1}: Uploading ${pendingFilesCount} files...`;
                        await this.uploadPendingFiles();
                        completedOperations++;
                    }
                    
                    // Now collect modified items data after files are uploaded
                    const { itemsToUpdate, newItemsToCreate } = this.collectModifiedItemsData();
                    
                    // Debug logging
                    console.log('Starting update with:', {
                        itemsToUpdate,
                        newItemsToCreate,
                        modifiedItems: Array.from(this.modifiedItems),
                        collectionId: this.currentCollectionId,
                        siteId: this.currentSiteId
                    });
                    
                    // Count remaining operations
                    if (itemsToUpdate.length > 0) totalOperations++;
                    if (newItemsToCreate.length > 0) totalOperations++;
                    
                    // Create new items first
                    if (newItemsToCreate.length > 0) {
                        this.elements.updatePublishButton.textContent = `Step ${completedOperations + 1}/${totalOperations + 1}: Creating ${newItemsToCreate.length} new items...`;
                        
                        console.log('Creating new items:', newItemsToCreate);
                        
                        const createResponse = await fetch(`/api/collections/${this.currentCollectionId}/items`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ items: newItemsToCreate })
                        });
                        
                        const createResult = await createResponse.json();
                        
                        console.log('Create response:', createResult);
                        
                        if (!createResult.success) {
                            throw new Error(`Failed to create new items: ${createResult.error}`);
                        }
                        
                        completedOperations++;
                        console.log('Successfully created new items:', createResult);
                    }
                    
                    // Update existing items
                    if (itemsToUpdate.length > 0) {
                        this.elements.updatePublishButton.textContent = `Step ${completedOperations + 1}/${totalOperations + 1}: Updating ${itemsToUpdate.length} existing items...`;
                        
                        console.log('Updating existing items:', itemsToUpdate);
                        
                        // Debug: Log the exact payload being sent
                        const updatePayload = { items: itemsToUpdate };
                        console.log('PATCH payload:', JSON.stringify(updatePayload, null, 2));
                        
                        const updateResponse = await fetch(`/api/collections/${this.currentCollectionId}/items`, {
                            method: 'PATCH',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(updatePayload)
                        });
                        
                        const updateResult = await updateResponse.json();
                        
                        console.log('Update response:', updateResult);
                        
                        if (!updateResult.success) {
                            throw new Error(`Failed to update existing items: ${updateResult.error}`);
                        }
                        
                        completedOperations++;
                        console.log('Successfully updated existing items:', updateResult);
                    }
                    
                    this.elements.updatePublishButton.textContent = `Step ${totalOperations + 1}/${totalOperations + 1}: Publishing site...`;
                    
                    // Publish site
                    console.log(`Publishing site ${this.currentSiteId}`);
                    const publishResponse = await fetch(`/api/sites/${this.currentSiteId}/publish`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ domains: [] })  // Publish to all domains
                    });
                    
                    const publishResult = await publishResponse.json();
                    
                    if (!publishResult.success) {
                        throw new Error(publishResult.error);
                    }
                    
                    const totalItems = itemsToUpdate.length + newItemsToCreate.length;
                    const createdText = newItemsToCreate.length > 0 ? `created ${newItemsToCreate.length}, ` : '';
                    const updatedText = itemsToUpdate.length > 0 ? `updated ${itemsToUpdate.length}, ` : '';
                    
                    this.showSuccess(
                        `✅ Success! ${createdText}${updatedText}and published the site. ` +
                        'Your changes are now live on the website.'
                    );
                    this.modifiedItems.clear();
                    this.clearModifiedStates();
                    
                } catch (error) {
                    console.error('Update operation failed:', error);
                    
                    // Create a more detailed error display
                    let errorDisplay = error.message;
                    let errorTitle = 'Update Failed';
                    
                    // Provide specific guidance for different error types
                    if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                        errorDisplay = 'Network error: Unable to connect to the server. Please check your connection and try again.';
                    } else if (error.message.includes('Unexpected token')) {
                        errorTitle = 'Items Updated, Publish May Have Failed';
                        errorDisplay = 'The items were updated successfully, but there was an issue with the publish step. Your changes are saved in Webflow but may not be live yet.\n\nYou can manually publish your site from the Webflow dashboard, or check the server logs for more details.';
                    } else if (error.message.includes('Server returned HTML')) {
                        errorTitle = 'Items Updated, Publish Failed';
                        errorDisplay = 'The items were updated successfully, but the publish step failed. Your changes are saved in Webflow but are not live yet.\n\nPlease manually publish your site from the Webflow dashboard.';
                    }
                    
                    this.showDetailedError(errorTitle, errorDisplay);
                } finally {
                    this.elements.updatePublishButton.disabled = false;
                    this.elements.updatePublishButton.textContent = 'Update & Publish';
                    this.updateCollectionInfo();
                }
            }
            
            collectModifiedItemsData() {
                const itemsToUpdate = [];
                const newItemsToCreate = [];
                
                this.modifiedItems.forEach(itemId => {
                    const fieldData = {};
                    const inputs = document.querySelectorAll(`[data-item-id="${itemId}"]`);
                    
                    console.log(`Processing item ${itemId}, found ${inputs.length} inputs`);
                    
                    inputs.forEach((input, index) => {
                        const fieldSlug = input.getAttribute('data-field-slug');
                        const fieldType = input.getAttribute('data-field-type');
                        
                        // Debug each input
                        console.log(`Input ${index}:`, {
                            element: input.tagName,
                            fieldSlug,
                            fieldType,
                            value: input.value || input.checked,
                            id: input.id
                        });
                        
                        // Skip inputs with undefined/null field slugs
                        if (!fieldSlug || fieldSlug === 'undefined' || fieldSlug === 'null') {
                            console.error(`Skipping input with invalid field slug:`, {
                                element: input,
                                fieldSlug,
                                fieldType,
                                attributes: Array.from(input.attributes).map(attr => `${attr.name}="${attr.value}"`)
                            });
                            return;
                        }
                        
                        // Skip inputs with undefined/null field types
                        if (!fieldType || fieldType === 'undefined' || fieldType === 'null') {
                            console.error(`Skipping input with invalid field type:`, {
                                element: input,
                                fieldSlug,
                                fieldType
                            });
                            return;
                        }
                        
                        const fieldValue = this.getFieldValue(input, fieldType);
                        
                        // Only include fields that have meaningful values
                        // Skip null values for reference fields and empty values for most fields
                        if (this.shouldIncludeField(fieldSlug, fieldValue, fieldType)) {
                            fieldData[fieldSlug] = fieldValue;
                            console.log(`Added field: ${fieldSlug} = ${JSON.stringify(fieldValue)}`);
                        } else {
                            console.log(`Skipped field: ${fieldSlug} (value: ${JSON.stringify(fieldValue)}, type: ${fieldType})`);
                        }
                    });
                    
                    // Only add items that have valid field data
                    if (Object.keys(fieldData).length > 0) {
                        const itemData = {
                            id: itemId,
                            fieldData: fieldData
                        };
                        
                        // Check if this is a new item
                        if (itemId.startsWith('new-item-')) {
                            newItemsToCreate.push(itemData);
                            console.log(`Added new item ${itemId} with fields:`, Object.keys(fieldData));
                        } else {
                            itemsToUpdate.push(itemData);
                            console.log(`Added existing item ${itemId} with fields:`, Object.keys(fieldData));
                        }
                    } else {
                        console.error(`No valid fields found for item ${itemId}`);
                    }
                });
                
                console.log('Final items to update:', itemsToUpdate);
                console.log('Final new items to create:', newItemsToCreate);
                return { itemsToUpdate, newItemsToCreate };
            }
            
            populateFieldSelect() {
                console.log('populateFieldSelect called');
                console.log('Collection schema:', this.collectionSchema);
                
                if (!this.collectionSchema || !this.collectionSchema.fields) {
                    console.error('No collection schema or fields available');
                    return;
                }
                
                this.elements.fieldSelect.innerHTML = '<option value="">Select a field...</option>';
                
                console.log('All fields:', this.collectionSchema.fields.map(f => ({ slug: f.slug, type: f.type, displayName: f.displayName })));
                
                // Include file/image fields AND also allow other field types for testing
                const fileFields = this.collectionSchema.fields.filter(field => 
                    field.type === 'ImageRef' || field.type === 'FileRef' || field.type === 'Image' || field.type === 'File'
                );
                
                console.log('Filtered file fields:', fileFields);
                
                if (fileFields.length === 0) {
                    console.log('No file/image fields found, showing all fields for debugging');
                    // If no file fields, show all fields for debugging
                    this.collectionSchema.fields.forEach(field => {
                        const option = document.createElement('option');
                        option.value = field.slug;
                        option.textContent = `${field.displayName} (${field.type})`;
                        option.setAttribute('data-field-type', field.type);
                        this.elements.fieldSelect.appendChild(option);
                    });
                } else {
                    fileFields.forEach(field => {
                        const option = document.createElement('option');
                        option.value = field.slug;
                        option.textContent = field.displayName;
                        option.setAttribute('data-field-type', field.type);
                        this.elements.fieldSelect.appendChild(option);
                    });
                }
                
                this.elements.fieldSelect.disabled = false;
                console.log('Field dropdown populated with', this.elements.fieldSelect.options.length - 1, 'options');
                
                // Remove any existing event listeners and add a new one
                this.elements.fieldSelect.removeEventListener('change', this.fieldSelectChangeHandler);
                this.fieldSelectChangeHandler = () => {
                    this.elements.bulkUploadButton.disabled = !this.elements.fieldSelect.value;
                    console.log('Field selected:', this.elements.fieldSelect.value);
                };
                this.elements.fieldSelect.addEventListener('change', this.fieldSelectChangeHandler);
            }
            
            triggerBulkUpload() {
                if (!this.elements.fieldSelect.value) {
                    this.showError('Please select a field to upload to.');
                    return;
                }
                
                this.elements.fileInput.click();
            }
            
            async handleFileSelection(event) {
                const files = Array.from(event.target.files);
                if (files.length === 0) return;
                
                const selectedField = this.elements.fieldSelect.value;
                const selectedFieldType = this.elements.fieldSelect.options[this.elements.fieldSelect.selectedIndex].getAttribute('data-field-type');
                
                console.log(`Adding ${files.length} files to field: ${selectedField}`);
                
                this.showUploadProgress(true);
                
                try {
                    let processedCount = 0;
                    
                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];
                        const progress = ((i + 1) / files.length) * 100;
                        
                        this.updateUploadProgress(progress, `Adding ${file.name} (${i + 1}/${files.length})`);
                        
                        // Create local file reference and new row
                        this.createItemWithLocalFile(selectedField, selectedFieldType, file);
                        processedCount++;
                    }
                    
                    this.showUploadProgress(false);
                    this.showSuccess(`Added ${processedCount} files. Edit details and click "Update & Publish" to save.`);
                    
                } catch (error) {
                    this.showUploadProgress(false);
                    this.showError(`Failed to add files: ${error.message}`);
                } finally {
                    this.elements.fileInput.value = ''; // Reset file input
                    this.updateCollectionInfo();
                }
            }
            
            createItemWithLocalFile(fieldSlug, fieldType, file) {
                // Generate a temporary ID for the new item
                this.newItemCounter++;
                const tempId = `new-item-${Date.now()}-${this.newItemCounter}`;
                
                console.log(`Creating new item with local file: ${file.name}`);
                
                // Store the file for later upload
                this.pendingFiles.set(tempId, {
                    file: file,
                    fieldSlug: fieldSlug,
                    fieldType: fieldType
                });
                
                // Create new item object
                const newItem = {
                    id: tempId,
                    fieldData: {},
                    isNew: true
                };
                
                // Initialize default values for all fields
                this.collectionSchema.fields.forEach(field => {
                    if (field.slug === fieldSlug) {
                        // Show local file preview for the selected field
                        if (fieldType === 'ImageRef' || fieldType === 'FileRef' || fieldType === 'Image' || fieldType === 'File') {
                            // Create a local preview URL
                            const previewUrl = URL.createObjectURL(file);
                            newItem.fieldData[field.slug] = { url: previewUrl, isLocal: true, fileName: file.name };
                        }
                    } else {
                        newItem.fieldData[field.slug] = this.getDefaultValueForField(field);
                    }
                });
                
                // Use filename as default name if there's a name field
                const nameField = this.collectionSchema.fields.find(f => f.slug === 'name' || f.slug === 'title');
                if (nameField) {
                    const baseName = file.name.replace(/\.[^/.]+$/, ''); // Remove extension
                    newItem.fieldData[nameField.slug] = baseName;
                }
                
                // Create the table row
                const newRow = this.createItemRow(newItem);
                newRow.classList.add('new-item-row');
                
                // Add a visual indicator that this item has a pending file
                newRow.classList.add('pending-upload');
                
                // Insert at the top of the table
                if (this.elements.tableBody.firstChild) {
                    this.elements.tableBody.insertBefore(newRow, this.elements.tableBody.firstChild);
                } else {
                    this.elements.tableBody.appendChild(newRow);
                }
                
                // Mark as modified
                this.modifiedItems.add(tempId);
            }
            
            async uploadPendingFiles() {
                if (this.pendingFiles.size === 0) {
                    return;
                }
                
                console.log(`Uploading ${this.pendingFiles.size} pending files`);
                
                let uploadCount = 0;
                const totalFiles = this.pendingFiles.size;
                
                // Create a copy of the entries to avoid modification during iteration
                const filesToUpload = Array.from(this.pendingFiles.entries());
                
                for (const [tempId, fileData] of filesToUpload) {
                    uploadCount++;
                    const { file, fieldSlug, fieldType } = fileData;
                    
                    this.elements.updatePublishButton.textContent = `Uploading ${file.name} (${uploadCount}/${totalFiles})...`;
                    
                    try {
                        console.log(`Uploading file: ${file.name} for item ${tempId}, field ${fieldSlug}`);
                        
                        // Create form data for file upload
                        const formData = new FormData();
                        formData.append('file', file);
                        formData.append('site_id', this.currentSiteId);
                        
                        const uploadResponse = await fetch('/api/upload-asset', {
                            method: 'POST',
                            body: formData
                        });
                        
                        const uploadResult = await uploadResponse.json();
                        
                        if (!uploadResult.success) {
                            throw new Error(`File upload failed: ${uploadResult.error}`);
                        }
                        
                        console.log(`File uploaded successfully: ${uploadResult.url}`);
                        
                        // Update the corresponding input field with the Webflow asset URL
                        const fileInput = document.querySelector(`[data-item-id="${tempId}"][data-field-slug="${fieldSlug}"]`);
                        if (fileInput) {
                            // For ImageRef/FileRef fields, find the URL input within
                            const urlInput = fileInput.querySelector('input') || fileInput;
                            if (urlInput) {
                                urlInput.value = uploadResult.url;
                                urlInput.classList.add('modified');
                                
                                // Update any preview images
                                const preview = fileInput.querySelector('img');
                                if (preview && fieldType === 'ImageRef') {
                                    preview.src = uploadResult.url;
                                }
                            }
                        }
                        
                        // Remove from pending files
                        this.pendingFiles.delete(tempId);
                        
                        // Remove the pending-upload class from the row
                        const row = document.querySelector(`tr[data-item-id="${tempId}"]`);
                        if (row) {
                            row.classList.remove('pending-upload');
                            row.classList.add('file-uploaded');
                        }
                        
                    } catch (error) {
                        console.error(`Failed to upload file ${file.name}:`, error);
                        throw new Error(`Failed to upload ${file.name}: ${error.message}`);
                    }
                }
                
                console.log(`Successfully uploaded all ${totalFiles} files`);
            }
            
            showUploadProgress(show) {
                this.elements.uploadProgress.style.display = show ? 'block' : 'none';
            }
            
            updateUploadProgress(percentage, statusText) {
                this.elements.uploadProgressFill.style.width = `${percentage}%`;
                this.elements.uploadStatus.textContent = statusText;
            }
            
            async deleteItem(itemId, rowElement) {
                // Check if this is a new item (not yet saved to Webflow)
                if (itemId.startsWith('new-item-')) {
                    // Clean up pending file if exists
                    if (this.pendingFiles.has(itemId)) {
                        const fileData = this.pendingFiles.get(itemId);
                        console.log(`Cleaning up pending file for deleted item: ${fileData.file.name}`);
                        this.pendingFiles.delete(itemId);
                    }
                    
                    // Remove from DOM and modified items set
                    this.modifiedItems.delete(itemId);
                    rowElement.remove();
                    this.updateCollectionInfo();
                    this.showSuccess('New item removed.');
                    return;
                }
                
                // Confirm deletion for existing items
                const confirmation = confirm('Are you sure you want to delete this item? This action cannot be undone.');
                if (!confirmation) return;
                
                // Add visual feedback
                rowElement.classList.add('deleting');
                const deleteButton = rowElement.querySelector('.btn-delete');
                deleteButton.textContent = 'Deleting...';
                deleteButton.disabled = true;
                
                try {
                    console.log(`Deleting item ${itemId}`);
                    
                    const response = await fetch(`/api/collections/${this.currentCollectionId}/items/${itemId}`, {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ isArchived: true })
                    });
                    
                    const result = await response.json();
                    
                    if (!result.success) {
                        throw new Error(result.error || 'Failed to delete item');
                    }
                    
                    // Remove from DOM and modified items set
                    this.modifiedItems.delete(itemId);
                    rowElement.remove();
                    this.updateCollectionInfo();
                    
                    this.showSuccess('Item deleted successfully.');
                    
                    console.log('Successfully deleted item:', itemId);
                    
                } catch (error) {
                    console.error('Delete operation failed:', error);
                    
                    // Remove visual feedback on error
                    rowElement.classList.remove('deleting');
                    deleteButton.textContent = 'Delete';
                    deleteButton.disabled = false;
                    
                    this.showError(`Failed to delete item: ${error.message}`);
                }
            }
            
            shouldIncludeField(fieldSlug, fieldValue, fieldType) {
                console.log(`shouldIncludeField check: ${fieldSlug}, value: ${JSON.stringify(fieldValue)}, type: ${fieldType}`);
                
                // Always include boolean fields (Switch)
                if (fieldType === 'Switch') {
                    console.log(`Including Switch field: ${fieldSlug}`);
                    return true;
                }
                
                // Skip null values for reference fields
                if ((fieldType === 'ItemRef' || fieldType === 'ItemRefSet') && (fieldValue === null || fieldValue === '')) {
                    console.log(`Skipping null/empty reference field: ${fieldSlug}`);
                    return false;
                }
                
                // Skip empty arrays for multi-reference fields
                if (fieldType === 'ItemRefSet' && Array.isArray(fieldValue) && fieldValue.length === 0) {
                    return false;
                }
                
                // Skip null/undefined values for file/image fields
                if ((fieldType === 'ImageRef' || fieldType === 'FileRef') && !fieldValue) {
                    return false;
                }
                
                // Skip empty strings for most text fields (but allow them for some fields like descriptions)
                if (fieldValue === '' && ['PlainText', 'RichText', 'Link', 'Email', 'Phone'].includes(fieldType)) {
                    // Allow empty strings for these field types
                    return true;
                }
                
                // Skip null/undefined values for number and date fields
                if ((fieldType === 'Number' || fieldType === 'DateTime') && (fieldValue === null || fieldValue === undefined)) {
                    return false;
                }
                
                // Include everything else
                const shouldInclude = fieldValue !== null && fieldValue !== undefined;
                console.log(`Final decision for ${fieldSlug}: ${shouldInclude}`);
                return shouldInclude;
            }
            
            getFieldValue(input, fieldType) {
                switch (fieldType) {
                    case 'Switch':
                        return input.checked;
                        
                    case 'Number':
                        return input.value ? parseFloat(input.value) : null;
                        
                    case 'DateTime':
                        return input.value ? new Date(input.value).toISOString() : null;
                        
                    case 'ImageRef':
                    case 'FileRef':
                        const urlInput = input.querySelector('input') || input;
                        // Skip local blob URLs - they should have been replaced by the upload process
                        if (urlInput.value && urlInput.value.startsWith('blob:')) {
                            console.warn(`Local blob URL detected for field, should have been uploaded: ${urlInput.value}`);
                            return null;
                        }
                        return urlInput.value ? { url: urlInput.value } : null;
                        
                    case 'ItemRef':
                        return input.value.trim() || null;
                        
                    case 'ItemRefSet':
                        if (!input.value || !input.value.trim()) {
                            return [];
                        }
                        return input.value.split(',').map(id => id.trim()).filter(id => id);
                        
                    default:
                        return input.value || null;
                }
            }
            
            clearModifiedStates() {
                document.querySelectorAll('.modified').forEach(element => {
                    element.classList.remove('modified');
                });
            }
            
            showLoading(show) {
                this.elements.loading.style.display = show ? 'block' : 'none';
            }
            
            showError(message) {
                this.showMessage(message, 'error');
            }
            
            showSuccess(message) {
                this.showMessage(message, 'success');
            }
            
            showMessage(message, type) {
                this.elements.messages.innerHTML = `<div class="${type}">${message}</div>`;
                setTimeout(() => this.hideMessages(), 5000);
            }
            
            hideMessages() {
                this.elements.messages.innerHTML = '';
            }
        }
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new WebflowBulkEditor();
        });
    </script>
</body>
</html>